// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// GamerMatchDetailsResponse gamer match details response
//
// swagger:model gamerMatchDetailsResponse
type GamerMatchDetailsResponse struct {

	// data
	Data *GamerMatchDetailsResponseData `json:"data,omitempty"`

	// status
	Status string `json:"status,omitempty"`

	// gamer match details response additional properties
	GamerMatchDetailsResponseAdditionalProperties map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *GamerMatchDetailsResponse) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// data
		Data *GamerMatchDetailsResponseData `json:"data,omitempty"`

		// status
		Status string `json:"status,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv GamerMatchDetailsResponse

	rcv.Data = stage1.Data
	rcv.Status = stage1.Status
	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "data")
	delete(stage2, "status")
	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.GamerMatchDetailsResponseAdditionalProperties = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m GamerMatchDetailsResponse) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// data
		Data *GamerMatchDetailsResponseData `json:"data,omitempty"`

		// status
		Status string `json:"status,omitempty"`
	}

	stage1.Data = m.Data
	stage1.Status = m.Status

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.GamerMatchDetailsResponseAdditionalProperties) == 0 {
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.GamerMatchDetailsResponseAdditionalProperties)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 {
		return additional, nil
	}

	// concatenate the 2 objects
	props[len(props)-1] = ','
	return append(props, additional[1:]...), nil
}

// Validate validates this gamer match details response
func (m *GamerMatchDetailsResponse) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateData(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GamerMatchDetailsResponse) validateData(formats strfmt.Registry) error {

	if swag.IsZero(m.Data) { // not required
		return nil
	}

	if m.Data != nil {
		if err := m.Data.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *GamerMatchDetailsResponse) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GamerMatchDetailsResponse) UnmarshalBinary(b []byte) error {
	var res GamerMatchDetailsResponse
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GamerMatchDetailsResponseData gamer match details response data
//
// swagger:model GamerMatchDetailsResponseData
type GamerMatchDetailsResponseData struct {

	// matches
	Matches []*GamerMatchDetailsResponseDataMatchesItems0 `json:"matches"`

	// message
	Message string `json:"message,omitempty"`

	// summary
	Summary map[string]GamerMatchDetailsResponseDataSummaryAnon `json:"summary,omitempty"`

	// type
	Type string `json:"type,omitempty"`

	// gamer match details response data additional properties
	GamerMatchDetailsResponseDataAdditionalProperties map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *GamerMatchDetailsResponseData) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// matches
		Matches []*GamerMatchDetailsResponseDataMatchesItems0 `json:"matches"`

		// message
		Message string `json:"message,omitempty"`

		// summary
		Summary map[string]GamerMatchDetailsResponseDataSummaryAnon `json:"summary,omitempty"`

		// type
		Type string `json:"type,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv GamerMatchDetailsResponseData

	rcv.Matches = stage1.Matches
	rcv.Message = stage1.Message
	rcv.Summary = stage1.Summary
	rcv.Type = stage1.Type
	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "matches")
	delete(stage2, "message")
	delete(stage2, "summary")
	delete(stage2, "type")
	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.GamerMatchDetailsResponseDataAdditionalProperties = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m GamerMatchDetailsResponseData) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// matches
		Matches []*GamerMatchDetailsResponseDataMatchesItems0 `json:"matches"`

		// message
		Message string `json:"message,omitempty"`

		// summary
		Summary map[string]GamerMatchDetailsResponseDataSummaryAnon `json:"summary,omitempty"`

		// type
		Type string `json:"type,omitempty"`
	}

	stage1.Matches = m.Matches
	stage1.Message = m.Message
	stage1.Summary = m.Summary
	stage1.Type = m.Type

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.GamerMatchDetailsResponseDataAdditionalProperties) == 0 {
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.GamerMatchDetailsResponseDataAdditionalProperties)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 {
		return additional, nil
	}

	// concatenate the 2 objects
	props[len(props)-1] = ','
	return append(props, additional[1:]...), nil
}

// Validate validates this gamer match details response data
func (m *GamerMatchDetailsResponseData) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMatches(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSummary(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GamerMatchDetailsResponseData) validateMatches(formats strfmt.Registry) error {

	if swag.IsZero(m.Matches) { // not required
		return nil
	}

	for i := 0; i < len(m.Matches); i++ {
		if swag.IsZero(m.Matches[i]) { // not required
			continue
		}

		if m.Matches[i] != nil {
			if err := m.Matches[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("data" + "." + "matches" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *GamerMatchDetailsResponseData) validateSummary(formats strfmt.Registry) error {

	if swag.IsZero(m.Summary) { // not required
		return nil
	}

	for k := range m.Summary {

		if swag.IsZero(m.Summary[k]) { // not required
			continue
		}
		if val, ok := m.Summary[k]; ok {
			if err := val.Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *GamerMatchDetailsResponseData) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GamerMatchDetailsResponseData) UnmarshalBinary(b []byte) error {
	var res GamerMatchDetailsResponseData
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GamerMatchDetailsResponseDataMatchesItems0 gamer match details response data matches items0
//
// swagger:model GamerMatchDetailsResponseDataMatchesItems0
type GamerMatchDetailsResponseDataMatchesItems0 struct {

	// all players
	AllPlayers string `json:"allPlayers,omitempty"`

	// arena
	Arena bool `json:"arena,omitempty"`

	// duration
	Duration int64 `json:"duration,omitempty"`

	// game battle
	GameBattle bool `json:"gameBattle,omitempty"`

	// game type
	GameType string `json:"gameType,omitempty"`

	// is present at end
	IsPresentAtEnd bool `json:"isPresentAtEnd,omitempty"`

	// map
	Map string `json:"map,omitempty"`

	// match ID
	MatchID string `json:"matchID,omitempty"`

	// mode
	Mode string `json:"mode,omitempty"`

	// player
	Player *GamerMatchDetailsResponseDataMatchesItems0Player `json:"player,omitempty"`

	// player stats
	PlayerStats *GamerMatchDetailsResponseDataMatchesItems0PlayerStats `json:"playerStats,omitempty"`

	// playlist name
	PlaylistName string `json:"playlistName,omitempty"`

	// private match
	PrivateMatch bool `json:"privateMatch,omitempty"`

	// result
	Result string `json:"result,omitempty"`

	// team1 score
	Team1Score int64 `json:"team1Score,omitempty"`

	// team2 score
	Team2Score int64 `json:"team2Score,omitempty"`

	// utc end seconds
	UtcEndSeconds int64 `json:"utcEndSeconds,omitempty"`

	// utc start seconds
	UtcStartSeconds int64 `json:"utcStartSeconds,omitempty"`

	// version
	Version int64 `json:"version,omitempty"`

	// weapon stats
	WeaponStats interface{} `json:"weaponStats,omitempty"`

	// winning team
	WinningTeam string `json:"winningTeam,omitempty"`

	// gamer match details response data matches items0 additional properties
	GamerMatchDetailsResponseDataMatchesItems0AdditionalProperties map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *GamerMatchDetailsResponseDataMatchesItems0) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// all players
		AllPlayers string `json:"allPlayers,omitempty"`

		// arena
		Arena bool `json:"arena,omitempty"`

		// duration
		Duration int64 `json:"duration,omitempty"`

		// game battle
		GameBattle bool `json:"gameBattle,omitempty"`

		// game type
		GameType string `json:"gameType,omitempty"`

		// is present at end
		IsPresentAtEnd bool `json:"isPresentAtEnd,omitempty"`

		// map
		Map string `json:"map,omitempty"`

		// match ID
		MatchID string `json:"matchID,omitempty"`

		// mode
		Mode string `json:"mode,omitempty"`

		// player
		Player *GamerMatchDetailsResponseDataMatchesItems0Player `json:"player,omitempty"`

		// player stats
		PlayerStats *GamerMatchDetailsResponseDataMatchesItems0PlayerStats `json:"playerStats,omitempty"`

		// playlist name
		PlaylistName string `json:"playlistName,omitempty"`

		// private match
		PrivateMatch bool `json:"privateMatch,omitempty"`

		// result
		Result string `json:"result,omitempty"`

		// team1 score
		Team1Score int64 `json:"team1Score,omitempty"`

		// team2 score
		Team2Score int64 `json:"team2Score,omitempty"`

		// utc end seconds
		UtcEndSeconds int64 `json:"utcEndSeconds,omitempty"`

		// utc start seconds
		UtcStartSeconds int64 `json:"utcStartSeconds,omitempty"`

		// version
		Version int64 `json:"version,omitempty"`

		// weapon stats
		WeaponStats interface{} `json:"weaponStats,omitempty"`

		// winning team
		WinningTeam string `json:"winningTeam,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv GamerMatchDetailsResponseDataMatchesItems0

	rcv.AllPlayers = stage1.AllPlayers
	rcv.Arena = stage1.Arena
	rcv.Duration = stage1.Duration
	rcv.GameBattle = stage1.GameBattle
	rcv.GameType = stage1.GameType
	rcv.IsPresentAtEnd = stage1.IsPresentAtEnd
	rcv.Map = stage1.Map
	rcv.MatchID = stage1.MatchID
	rcv.Mode = stage1.Mode
	rcv.Player = stage1.Player
	rcv.PlayerStats = stage1.PlayerStats
	rcv.PlaylistName = stage1.PlaylistName
	rcv.PrivateMatch = stage1.PrivateMatch
	rcv.Result = stage1.Result
	rcv.Team1Score = stage1.Team1Score
	rcv.Team2Score = stage1.Team2Score
	rcv.UtcEndSeconds = stage1.UtcEndSeconds
	rcv.UtcStartSeconds = stage1.UtcStartSeconds
	rcv.Version = stage1.Version
	rcv.WeaponStats = stage1.WeaponStats
	rcv.WinningTeam = stage1.WinningTeam
	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "allPlayers")
	delete(stage2, "arena")
	delete(stage2, "duration")
	delete(stage2, "gameBattle")
	delete(stage2, "gameType")
	delete(stage2, "isPresentAtEnd")
	delete(stage2, "map")
	delete(stage2, "matchID")
	delete(stage2, "mode")
	delete(stage2, "player")
	delete(stage2, "playerStats")
	delete(stage2, "playlistName")
	delete(stage2, "privateMatch")
	delete(stage2, "result")
	delete(stage2, "team1Score")
	delete(stage2, "team2Score")
	delete(stage2, "utcEndSeconds")
	delete(stage2, "utcStartSeconds")
	delete(stage2, "version")
	delete(stage2, "weaponStats")
	delete(stage2, "winningTeam")
	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.GamerMatchDetailsResponseDataMatchesItems0AdditionalProperties = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m GamerMatchDetailsResponseDataMatchesItems0) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// all players
		AllPlayers string `json:"allPlayers,omitempty"`

		// arena
		Arena bool `json:"arena,omitempty"`

		// duration
		Duration int64 `json:"duration,omitempty"`

		// game battle
		GameBattle bool `json:"gameBattle,omitempty"`

		// game type
		GameType string `json:"gameType,omitempty"`

		// is present at end
		IsPresentAtEnd bool `json:"isPresentAtEnd,omitempty"`

		// map
		Map string `json:"map,omitempty"`

		// match ID
		MatchID string `json:"matchID,omitempty"`

		// mode
		Mode string `json:"mode,omitempty"`

		// player
		Player *GamerMatchDetailsResponseDataMatchesItems0Player `json:"player,omitempty"`

		// player stats
		PlayerStats *GamerMatchDetailsResponseDataMatchesItems0PlayerStats `json:"playerStats,omitempty"`

		// playlist name
		PlaylistName string `json:"playlistName,omitempty"`

		// private match
		PrivateMatch bool `json:"privateMatch,omitempty"`

		// result
		Result string `json:"result,omitempty"`

		// team1 score
		Team1Score int64 `json:"team1Score,omitempty"`

		// team2 score
		Team2Score int64 `json:"team2Score,omitempty"`

		// utc end seconds
		UtcEndSeconds int64 `json:"utcEndSeconds,omitempty"`

		// utc start seconds
		UtcStartSeconds int64 `json:"utcStartSeconds,omitempty"`

		// version
		Version int64 `json:"version,omitempty"`

		// weapon stats
		WeaponStats interface{} `json:"weaponStats,omitempty"`

		// winning team
		WinningTeam string `json:"winningTeam,omitempty"`
	}

	stage1.AllPlayers = m.AllPlayers
	stage1.Arena = m.Arena
	stage1.Duration = m.Duration
	stage1.GameBattle = m.GameBattle
	stage1.GameType = m.GameType
	stage1.IsPresentAtEnd = m.IsPresentAtEnd
	stage1.Map = m.Map
	stage1.MatchID = m.MatchID
	stage1.Mode = m.Mode
	stage1.Player = m.Player
	stage1.PlayerStats = m.PlayerStats
	stage1.PlaylistName = m.PlaylistName
	stage1.PrivateMatch = m.PrivateMatch
	stage1.Result = m.Result
	stage1.Team1Score = m.Team1Score
	stage1.Team2Score = m.Team2Score
	stage1.UtcEndSeconds = m.UtcEndSeconds
	stage1.UtcStartSeconds = m.UtcStartSeconds
	stage1.Version = m.Version
	stage1.WeaponStats = m.WeaponStats
	stage1.WinningTeam = m.WinningTeam

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.GamerMatchDetailsResponseDataMatchesItems0AdditionalProperties) == 0 {
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.GamerMatchDetailsResponseDataMatchesItems0AdditionalProperties)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 {
		return additional, nil
	}

	// concatenate the 2 objects
	props[len(props)-1] = ','
	return append(props, additional[1:]...), nil
}

// Validate validates this gamer match details response data matches items0
func (m *GamerMatchDetailsResponseDataMatchesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePlayer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlayerStats(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GamerMatchDetailsResponseDataMatchesItems0) validatePlayer(formats strfmt.Registry) error {

	if swag.IsZero(m.Player) { // not required
		return nil
	}

	if m.Player != nil {
		if err := m.Player.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("player")
			}
			return err
		}
	}

	return nil
}

func (m *GamerMatchDetailsResponseDataMatchesItems0) validatePlayerStats(formats strfmt.Registry) error {

	if swag.IsZero(m.PlayerStats) { // not required
		return nil
	}

	if m.PlayerStats != nil {
		if err := m.PlayerStats.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("playerStats")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *GamerMatchDetailsResponseDataMatchesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GamerMatchDetailsResponseDataMatchesItems0) UnmarshalBinary(b []byte) error {
	var res GamerMatchDetailsResponseDataMatchesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GamerMatchDetailsResponseDataMatchesItems0Player gamer match details response data matches items0 player
//
// swagger:model GamerMatchDetailsResponseDataMatchesItems0Player
type GamerMatchDetailsResponseDataMatchesItems0Player struct {

	// awards
	Awards interface{} `json:"awards,omitempty"`

	// loadout
	Loadout []interface{} `json:"loadout"`

	// most killed
	MostKilled string `json:"mostKilled,omitempty"`

	// nemesis
	Nemesis string `json:"nemesis,omitempty"`

	// platform
	Platform string `json:"platform,omitempty"`

	// team
	Team string `json:"team,omitempty"`

	// gamer match details response data matches items0 player additional properties
	GamerMatchDetailsResponseDataMatchesItems0PlayerAdditionalProperties map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *GamerMatchDetailsResponseDataMatchesItems0Player) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// awards
		Awards interface{} `json:"awards,omitempty"`

		// loadout
		Loadout []interface{} `json:"loadout"`

		// most killed
		MostKilled string `json:"mostKilled,omitempty"`

		// nemesis
		Nemesis string `json:"nemesis,omitempty"`

		// platform
		Platform string `json:"platform,omitempty"`

		// team
		Team string `json:"team,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv GamerMatchDetailsResponseDataMatchesItems0Player

	rcv.Awards = stage1.Awards
	rcv.Loadout = stage1.Loadout
	rcv.MostKilled = stage1.MostKilled
	rcv.Nemesis = stage1.Nemesis
	rcv.Platform = stage1.Platform
	rcv.Team = stage1.Team
	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "awards")
	delete(stage2, "loadout")
	delete(stage2, "mostKilled")
	delete(stage2, "nemesis")
	delete(stage2, "platform")
	delete(stage2, "team")
	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.GamerMatchDetailsResponseDataMatchesItems0PlayerAdditionalProperties = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m GamerMatchDetailsResponseDataMatchesItems0Player) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// awards
		Awards interface{} `json:"awards,omitempty"`

		// loadout
		Loadout []interface{} `json:"loadout"`

		// most killed
		MostKilled string `json:"mostKilled,omitempty"`

		// nemesis
		Nemesis string `json:"nemesis,omitempty"`

		// platform
		Platform string `json:"platform,omitempty"`

		// team
		Team string `json:"team,omitempty"`
	}

	stage1.Awards = m.Awards
	stage1.Loadout = m.Loadout
	stage1.MostKilled = m.MostKilled
	stage1.Nemesis = m.Nemesis
	stage1.Platform = m.Platform
	stage1.Team = m.Team

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.GamerMatchDetailsResponseDataMatchesItems0PlayerAdditionalProperties) == 0 {
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.GamerMatchDetailsResponseDataMatchesItems0PlayerAdditionalProperties)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 {
		return additional, nil
	}

	// concatenate the 2 objects
	props[len(props)-1] = ','
	return append(props, additional[1:]...), nil
}

// Validate validates this gamer match details response data matches items0 player
func (m *GamerMatchDetailsResponseDataMatchesItems0Player) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *GamerMatchDetailsResponseDataMatchesItems0Player) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GamerMatchDetailsResponseDataMatchesItems0Player) UnmarshalBinary(b []byte) error {
	var res GamerMatchDetailsResponseDataMatchesItems0Player
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GamerMatchDetailsResponseDataMatchesItems0PlayerStats gamer match details response data matches items0 player stats
//
// swagger:model GamerMatchDetailsResponseDataMatchesItems0PlayerStats
type GamerMatchDetailsResponseDataMatchesItems0PlayerStats struct {

	// accuracy
	Accuracy float64 `json:"accuracy,omitempty"`

	// assists
	Assists float64 `json:"assists,omitempty"`

	// damage dealt
	DamageDealt float64 `json:"damageDealt,omitempty"`

	// deaths
	Deaths float64 `json:"deaths,omitempty"`

	// ekia
	Ekia float64 `json:"ekia,omitempty"`

	// ekiad ratio
	EkiadRatio float64 `json:"ekiadRatio,omitempty"`

	// headshots
	Headshots float64 `json:"headshots,omitempty"`

	// highest multikill
	HighestMultikill float64 `json:"highestMultikill,omitempty"`

	// highest streak
	HighestStreak float64 `json:"highestStreak,omitempty"`

	// hits
	Hits float64 `json:"hits,omitempty"`

	// kd ratio
	KdRatio float64 `json:"kdRatio,omitempty"`

	// kills
	Kills float64 `json:"kills,omitempty"`

	// multikills
	Multikills float64 `json:"multikills,omitempty"`

	// objectives
	Objectives float64 `json:"objectives,omitempty"`

	// rank at end
	RankAtEnd float64 `json:"rankAtEnd,omitempty"`

	// score
	Score float64 `json:"score,omitempty"`

	// score per minute
	ScorePerMinute float64 `json:"scorePerMinute,omitempty"`

	// shots
	Shots float64 `json:"shots,omitempty"`

	// shots fired
	ShotsFired float64 `json:"shotsFired,omitempty"`

	// shots landed
	ShotsLanded float64 `json:"shotsLanded,omitempty"`

	// shots missed
	ShotsMissed float64 `json:"shotsMissed,omitempty"`

	// suicides
	Suicides float64 `json:"suicides,omitempty"`

	// time played
	TimePlayed float64 `json:"timePlayed,omitempty"`

	// time played alive
	TimePlayedAlive float64 `json:"timePlayedAlive,omitempty"`

	// xp at end
	XpAtEnd float64 `json:"xpAtEnd,omitempty"`

	// gamer match details response data matches items0 player stats additional properties
	GamerMatchDetailsResponseDataMatchesItems0PlayerStatsAdditionalProperties map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *GamerMatchDetailsResponseDataMatchesItems0PlayerStats) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// accuracy
		Accuracy float64 `json:"accuracy,omitempty"`

		// assists
		Assists float64 `json:"assists,omitempty"`

		// damage dealt
		DamageDealt float64 `json:"damageDealt,omitempty"`

		// deaths
		Deaths float64 `json:"deaths,omitempty"`

		// ekia
		Ekia float64 `json:"ekia,omitempty"`

		// ekiad ratio
		EkiadRatio float64 `json:"ekiadRatio,omitempty"`

		// headshots
		Headshots float64 `json:"headshots,omitempty"`

		// highest multikill
		HighestMultikill float64 `json:"highestMultikill,omitempty"`

		// highest streak
		HighestStreak float64 `json:"highestStreak,omitempty"`

		// hits
		Hits float64 `json:"hits,omitempty"`

		// kd ratio
		KdRatio float64 `json:"kdRatio,omitempty"`

		// kills
		Kills float64 `json:"kills,omitempty"`

		// multikills
		Multikills float64 `json:"multikills,omitempty"`

		// objectives
		Objectives float64 `json:"objectives,omitempty"`

		// rank at end
		RankAtEnd float64 `json:"rankAtEnd,omitempty"`

		// score
		Score float64 `json:"score,omitempty"`

		// score per minute
		ScorePerMinute float64 `json:"scorePerMinute,omitempty"`

		// shots
		Shots float64 `json:"shots,omitempty"`

		// shots fired
		ShotsFired float64 `json:"shotsFired,omitempty"`

		// shots landed
		ShotsLanded float64 `json:"shotsLanded,omitempty"`

		// shots missed
		ShotsMissed float64 `json:"shotsMissed,omitempty"`

		// suicides
		Suicides float64 `json:"suicides,omitempty"`

		// time played
		TimePlayed float64 `json:"timePlayed,omitempty"`

		// time played alive
		TimePlayedAlive float64 `json:"timePlayedAlive,omitempty"`

		// xp at end
		XpAtEnd float64 `json:"xpAtEnd,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv GamerMatchDetailsResponseDataMatchesItems0PlayerStats

	rcv.Accuracy = stage1.Accuracy
	rcv.Assists = stage1.Assists
	rcv.DamageDealt = stage1.DamageDealt
	rcv.Deaths = stage1.Deaths
	rcv.Ekia = stage1.Ekia
	rcv.EkiadRatio = stage1.EkiadRatio
	rcv.Headshots = stage1.Headshots
	rcv.HighestMultikill = stage1.HighestMultikill
	rcv.HighestStreak = stage1.HighestStreak
	rcv.Hits = stage1.Hits
	rcv.KdRatio = stage1.KdRatio
	rcv.Kills = stage1.Kills
	rcv.Multikills = stage1.Multikills
	rcv.Objectives = stage1.Objectives
	rcv.RankAtEnd = stage1.RankAtEnd
	rcv.Score = stage1.Score
	rcv.ScorePerMinute = stage1.ScorePerMinute
	rcv.Shots = stage1.Shots
	rcv.ShotsFired = stage1.ShotsFired
	rcv.ShotsLanded = stage1.ShotsLanded
	rcv.ShotsMissed = stage1.ShotsMissed
	rcv.Suicides = stage1.Suicides
	rcv.TimePlayed = stage1.TimePlayed
	rcv.TimePlayedAlive = stage1.TimePlayedAlive
	rcv.XpAtEnd = stage1.XpAtEnd
	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "accuracy")
	delete(stage2, "assists")
	delete(stage2, "damageDealt")
	delete(stage2, "deaths")
	delete(stage2, "ekia")
	delete(stage2, "ekiadRatio")
	delete(stage2, "headshots")
	delete(stage2, "highestMultikill")
	delete(stage2, "highestStreak")
	delete(stage2, "hits")
	delete(stage2, "kdRatio")
	delete(stage2, "kills")
	delete(stage2, "multikills")
	delete(stage2, "objectives")
	delete(stage2, "rankAtEnd")
	delete(stage2, "score")
	delete(stage2, "scorePerMinute")
	delete(stage2, "shots")
	delete(stage2, "shotsFired")
	delete(stage2, "shotsLanded")
	delete(stage2, "shotsMissed")
	delete(stage2, "suicides")
	delete(stage2, "timePlayed")
	delete(stage2, "timePlayedAlive")
	delete(stage2, "xpAtEnd")
	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.GamerMatchDetailsResponseDataMatchesItems0PlayerStatsAdditionalProperties = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m GamerMatchDetailsResponseDataMatchesItems0PlayerStats) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// accuracy
		Accuracy float64 `json:"accuracy,omitempty"`

		// assists
		Assists float64 `json:"assists,omitempty"`

		// damage dealt
		DamageDealt float64 `json:"damageDealt,omitempty"`

		// deaths
		Deaths float64 `json:"deaths,omitempty"`

		// ekia
		Ekia float64 `json:"ekia,omitempty"`

		// ekiad ratio
		EkiadRatio float64 `json:"ekiadRatio,omitempty"`

		// headshots
		Headshots float64 `json:"headshots,omitempty"`

		// highest multikill
		HighestMultikill float64 `json:"highestMultikill,omitempty"`

		// highest streak
		HighestStreak float64 `json:"highestStreak,omitempty"`

		// hits
		Hits float64 `json:"hits,omitempty"`

		// kd ratio
		KdRatio float64 `json:"kdRatio,omitempty"`

		// kills
		Kills float64 `json:"kills,omitempty"`

		// multikills
		Multikills float64 `json:"multikills,omitempty"`

		// objectives
		Objectives float64 `json:"objectives,omitempty"`

		// rank at end
		RankAtEnd float64 `json:"rankAtEnd,omitempty"`

		// score
		Score float64 `json:"score,omitempty"`

		// score per minute
		ScorePerMinute float64 `json:"scorePerMinute,omitempty"`

		// shots
		Shots float64 `json:"shots,omitempty"`

		// shots fired
		ShotsFired float64 `json:"shotsFired,omitempty"`

		// shots landed
		ShotsLanded float64 `json:"shotsLanded,omitempty"`

		// shots missed
		ShotsMissed float64 `json:"shotsMissed,omitempty"`

		// suicides
		Suicides float64 `json:"suicides,omitempty"`

		// time played
		TimePlayed float64 `json:"timePlayed,omitempty"`

		// time played alive
		TimePlayedAlive float64 `json:"timePlayedAlive,omitempty"`

		// xp at end
		XpAtEnd float64 `json:"xpAtEnd,omitempty"`
	}

	stage1.Accuracy = m.Accuracy
	stage1.Assists = m.Assists
	stage1.DamageDealt = m.DamageDealt
	stage1.Deaths = m.Deaths
	stage1.Ekia = m.Ekia
	stage1.EkiadRatio = m.EkiadRatio
	stage1.Headshots = m.Headshots
	stage1.HighestMultikill = m.HighestMultikill
	stage1.HighestStreak = m.HighestStreak
	stage1.Hits = m.Hits
	stage1.KdRatio = m.KdRatio
	stage1.Kills = m.Kills
	stage1.Multikills = m.Multikills
	stage1.Objectives = m.Objectives
	stage1.RankAtEnd = m.RankAtEnd
	stage1.Score = m.Score
	stage1.ScorePerMinute = m.ScorePerMinute
	stage1.Shots = m.Shots
	stage1.ShotsFired = m.ShotsFired
	stage1.ShotsLanded = m.ShotsLanded
	stage1.ShotsMissed = m.ShotsMissed
	stage1.Suicides = m.Suicides
	stage1.TimePlayed = m.TimePlayed
	stage1.TimePlayedAlive = m.TimePlayedAlive
	stage1.XpAtEnd = m.XpAtEnd

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.GamerMatchDetailsResponseDataMatchesItems0PlayerStatsAdditionalProperties) == 0 {
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.GamerMatchDetailsResponseDataMatchesItems0PlayerStatsAdditionalProperties)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 {
		return additional, nil
	}

	// concatenate the 2 objects
	props[len(props)-1] = ','
	return append(props, additional[1:]...), nil
}

// Validate validates this gamer match details response data matches items0 player stats
func (m *GamerMatchDetailsResponseDataMatchesItems0PlayerStats) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *GamerMatchDetailsResponseDataMatchesItems0PlayerStats) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GamerMatchDetailsResponseDataMatchesItems0PlayerStats) UnmarshalBinary(b []byte) error {
	var res GamerMatchDetailsResponseDataMatchesItems0PlayerStats
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GamerMatchDetailsResponseDataSummaryAnon gamer match details response data summary anon
//
// swagger:model GamerMatchDetailsResponseDataSummaryAnon
type GamerMatchDetailsResponseDataSummaryAnon struct {

	// accuracy
	Accuracy float64 `json:"accuracy,omitempty"`

	// assists
	Assists float64 `json:"assists,omitempty"`

	// avg life time
	AvgLifeTime float64 `json:"avgLifeTime,omitempty"`

	// damage dealt
	DamageDealt float64 `json:"damageDealt,omitempty"`

	// deaths
	Deaths float64 `json:"deaths,omitempty"`

	// draws
	Draws float64 `json:"draws,omitempty"`

	// ekia
	Ekia float64 `json:"ekia,omitempty"`

	// ekia per game
	EkiaPerGame float64 `json:"ekiaPerGame,omitempty"`

	// ekiad ratio
	EkiadRatio float64 `json:"ekiadRatio,omitempty"`

	// headshot percentage
	HeadshotPercentage float64 `json:"headshotPercentage,omitempty"`

	// headshots
	Headshots float64 `json:"headshots,omitempty"`

	// highest multikill
	HighestMultikill float64 `json:"highestMultikill,omitempty"`

	// highest streak
	HighestStreak float64 `json:"highestStreak,omitempty"`

	// hits
	Hits float64 `json:"hits,omitempty"`

	// kd ratio
	KdRatio float64 `json:"kdRatio,omitempty"`

	// kills
	Kills float64 `json:"kills,omitempty"`

	// losses
	Losses float64 `json:"losses,omitempty"`

	// matches played
	MatchesPlayed float64 `json:"matchesPlayed,omitempty"`

	// multikills
	Multikills float64 `json:"multikills,omitempty"`

	// objectives
	Objectives float64 `json:"objectives,omitempty"`

	// score
	Score float64 `json:"score,omitempty"`

	// score per game
	ScorePerGame float64 `json:"scorePerGame,omitempty"`

	// score per minute
	ScorePerMinute float64 `json:"scorePerMinute,omitempty"`

	// shots
	Shots float64 `json:"shots,omitempty"`

	// shots fired
	ShotsFired float64 `json:"shotsFired,omitempty"`

	// shots landed
	ShotsLanded float64 `json:"shotsLanded,omitempty"`

	// shots missed
	ShotsMissed float64 `json:"shotsMissed,omitempty"`

	// suicides
	Suicides float64 `json:"suicides,omitempty"`

	// time played
	TimePlayed float64 `json:"timePlayed,omitempty"`

	// time played alive
	TimePlayedAlive float64 `json:"timePlayedAlive,omitempty"`

	// wins
	Wins float64 `json:"wins,omitempty"`

	// wl ratio
	WlRatio float64 `json:"wlRatio,omitempty"`
}

// Validate validates this gamer match details response data summary anon
func (m *GamerMatchDetailsResponseDataSummaryAnon) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *GamerMatchDetailsResponseDataSummaryAnon) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GamerMatchDetailsResponseDataSummaryAnon) UnmarshalBinary(b []byte) error {
	var res GamerMatchDetailsResponseDataSummaryAnon
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
