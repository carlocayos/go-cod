// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// FullMatchInfoResponse full match info response
//
// swagger:model fullMatchInfoResponse
type FullMatchInfoResponse struct {

	// data
	Data *FullMatchInfoResponseData `json:"data,omitempty"`

	// status
	Status string `json:"status,omitempty"`

	// full match info response additional properties
	FullMatchInfoResponseAdditionalProperties map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *FullMatchInfoResponse) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// data
		Data *FullMatchInfoResponseData `json:"data,omitempty"`

		// status
		Status string `json:"status,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv FullMatchInfoResponse

	rcv.Data = stage1.Data
	rcv.Status = stage1.Status
	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "data")
	delete(stage2, "status")
	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.FullMatchInfoResponseAdditionalProperties = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m FullMatchInfoResponse) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// data
		Data *FullMatchInfoResponseData `json:"data,omitempty"`

		// status
		Status string `json:"status,omitempty"`
	}

	stage1.Data = m.Data
	stage1.Status = m.Status

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.FullMatchInfoResponseAdditionalProperties) == 0 {
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.FullMatchInfoResponseAdditionalProperties)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 {
		return additional, nil
	}

	// concatenate the 2 objects
	props[len(props)-1] = ','
	return append(props, additional[1:]...), nil
}

// Validate validates this full match info response
func (m *FullMatchInfoResponse) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateData(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FullMatchInfoResponse) validateData(formats strfmt.Registry) error {

	if swag.IsZero(m.Data) { // not required
		return nil
	}

	if m.Data != nil {
		if err := m.Data.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FullMatchInfoResponse) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FullMatchInfoResponse) UnmarshalBinary(b []byte) error {
	var res FullMatchInfoResponse
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FullMatchInfoResponseData full match info response data
//
// swagger:model FullMatchInfoResponseData
type FullMatchInfoResponseData struct {

	// all players
	AllPlayers []*FullMatchInfoResponseDataAllPlayersItems0 `json:"allPlayers"`

	// message
	Message string `json:"message,omitempty"`

	// type
	Type string `json:"type,omitempty"`

	// full match info response data additional properties
	FullMatchInfoResponseDataAdditionalProperties map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *FullMatchInfoResponseData) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// all players
		AllPlayers []*FullMatchInfoResponseDataAllPlayersItems0 `json:"allPlayers"`

		// message
		Message string `json:"message,omitempty"`

		// type
		Type string `json:"type,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv FullMatchInfoResponseData

	rcv.AllPlayers = stage1.AllPlayers
	rcv.Message = stage1.Message
	rcv.Type = stage1.Type
	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "allPlayers")
	delete(stage2, "message")
	delete(stage2, "type")
	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.FullMatchInfoResponseDataAdditionalProperties = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m FullMatchInfoResponseData) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// all players
		AllPlayers []*FullMatchInfoResponseDataAllPlayersItems0 `json:"allPlayers"`

		// message
		Message string `json:"message,omitempty"`

		// type
		Type string `json:"type,omitempty"`
	}

	stage1.AllPlayers = m.AllPlayers
	stage1.Message = m.Message
	stage1.Type = m.Type

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.FullMatchInfoResponseDataAdditionalProperties) == 0 {
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.FullMatchInfoResponseDataAdditionalProperties)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 {
		return additional, nil
	}

	// concatenate the 2 objects
	props[len(props)-1] = ','
	return append(props, additional[1:]...), nil
}

// Validate validates this full match info response data
func (m *FullMatchInfoResponseData) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAllPlayers(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FullMatchInfoResponseData) validateAllPlayers(formats strfmt.Registry) error {

	if swag.IsZero(m.AllPlayers) { // not required
		return nil
	}

	for i := 0; i < len(m.AllPlayers); i++ {
		if swag.IsZero(m.AllPlayers[i]) { // not required
			continue
		}

		if m.AllPlayers[i] != nil {
			if err := m.AllPlayers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("data" + "." + "allPlayers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *FullMatchInfoResponseData) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FullMatchInfoResponseData) UnmarshalBinary(b []byte) error {
	var res FullMatchInfoResponseData
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FullMatchInfoResponseDataAllPlayersItems0 full match info response data all players items0
//
// swagger:model FullMatchInfoResponseDataAllPlayersItems0
type FullMatchInfoResponseDataAllPlayersItems0 struct {

	// draw
	Draw bool `json:"draw,omitempty"`

	// duration
	Duration int64 `json:"duration,omitempty"`

	// game type
	GameType string `json:"gameType,omitempty"`

	// map
	Map string `json:"map,omitempty"`

	// match ID
	MatchID string `json:"matchID,omitempty"`

	// mode
	Mode string `json:"mode,omitempty"`

	// player
	Player *FullMatchInfoResponseDataAllPlayersItems0Player `json:"player,omitempty"`

	// player count
	PlayerCount int64 `json:"playerCount,omitempty"`

	// player stats
	PlayerStats *FullMatchInfoResponseDataAllPlayersItems0PlayerStats `json:"playerStats,omitempty"`

	// playlist name
	PlaylistName interface{} `json:"playlistName,omitempty"`

	// private match
	PrivateMatch bool `json:"privateMatch,omitempty"`

	// ranked teams
	RankedTeams interface{} `json:"rankedTeams,omitempty"`

	// team count
	TeamCount int64 `json:"teamCount,omitempty"`

	// utc end seconds
	UtcEndSeconds int64 `json:"utcEndSeconds,omitempty"`

	// utc start seconds
	UtcStartSeconds int64 `json:"utcStartSeconds,omitempty"`

	// version
	Version int64 `json:"version,omitempty"`

	// full match info response data all players items0 additional properties
	FullMatchInfoResponseDataAllPlayersItems0AdditionalProperties map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *FullMatchInfoResponseDataAllPlayersItems0) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// draw
		Draw bool `json:"draw,omitempty"`

		// duration
		Duration int64 `json:"duration,omitempty"`

		// game type
		GameType string `json:"gameType,omitempty"`

		// map
		Map string `json:"map,omitempty"`

		// match ID
		MatchID string `json:"matchID,omitempty"`

		// mode
		Mode string `json:"mode,omitempty"`

		// player
		Player *FullMatchInfoResponseDataAllPlayersItems0Player `json:"player,omitempty"`

		// player count
		PlayerCount int64 `json:"playerCount,omitempty"`

		// player stats
		PlayerStats *FullMatchInfoResponseDataAllPlayersItems0PlayerStats `json:"playerStats,omitempty"`

		// playlist name
		PlaylistName interface{} `json:"playlistName,omitempty"`

		// private match
		PrivateMatch bool `json:"privateMatch,omitempty"`

		// ranked teams
		RankedTeams interface{} `json:"rankedTeams,omitempty"`

		// team count
		TeamCount int64 `json:"teamCount,omitempty"`

		// utc end seconds
		UtcEndSeconds int64 `json:"utcEndSeconds,omitempty"`

		// utc start seconds
		UtcStartSeconds int64 `json:"utcStartSeconds,omitempty"`

		// version
		Version int64 `json:"version,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv FullMatchInfoResponseDataAllPlayersItems0

	rcv.Draw = stage1.Draw
	rcv.Duration = stage1.Duration
	rcv.GameType = stage1.GameType
	rcv.Map = stage1.Map
	rcv.MatchID = stage1.MatchID
	rcv.Mode = stage1.Mode
	rcv.Player = stage1.Player
	rcv.PlayerCount = stage1.PlayerCount
	rcv.PlayerStats = stage1.PlayerStats
	rcv.PlaylistName = stage1.PlaylistName
	rcv.PrivateMatch = stage1.PrivateMatch
	rcv.RankedTeams = stage1.RankedTeams
	rcv.TeamCount = stage1.TeamCount
	rcv.UtcEndSeconds = stage1.UtcEndSeconds
	rcv.UtcStartSeconds = stage1.UtcStartSeconds
	rcv.Version = stage1.Version
	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "draw")
	delete(stage2, "duration")
	delete(stage2, "gameType")
	delete(stage2, "map")
	delete(stage2, "matchID")
	delete(stage2, "mode")
	delete(stage2, "player")
	delete(stage2, "playerCount")
	delete(stage2, "playerStats")
	delete(stage2, "playlistName")
	delete(stage2, "privateMatch")
	delete(stage2, "rankedTeams")
	delete(stage2, "teamCount")
	delete(stage2, "utcEndSeconds")
	delete(stage2, "utcStartSeconds")
	delete(stage2, "version")
	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.FullMatchInfoResponseDataAllPlayersItems0AdditionalProperties = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m FullMatchInfoResponseDataAllPlayersItems0) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// draw
		Draw bool `json:"draw,omitempty"`

		// duration
		Duration int64 `json:"duration,omitempty"`

		// game type
		GameType string `json:"gameType,omitempty"`

		// map
		Map string `json:"map,omitempty"`

		// match ID
		MatchID string `json:"matchID,omitempty"`

		// mode
		Mode string `json:"mode,omitempty"`

		// player
		Player *FullMatchInfoResponseDataAllPlayersItems0Player `json:"player,omitempty"`

		// player count
		PlayerCount int64 `json:"playerCount,omitempty"`

		// player stats
		PlayerStats *FullMatchInfoResponseDataAllPlayersItems0PlayerStats `json:"playerStats,omitempty"`

		// playlist name
		PlaylistName interface{} `json:"playlistName,omitempty"`

		// private match
		PrivateMatch bool `json:"privateMatch,omitempty"`

		// ranked teams
		RankedTeams interface{} `json:"rankedTeams,omitempty"`

		// team count
		TeamCount int64 `json:"teamCount,omitempty"`

		// utc end seconds
		UtcEndSeconds int64 `json:"utcEndSeconds,omitempty"`

		// utc start seconds
		UtcStartSeconds int64 `json:"utcStartSeconds,omitempty"`

		// version
		Version int64 `json:"version,omitempty"`
	}

	stage1.Draw = m.Draw
	stage1.Duration = m.Duration
	stage1.GameType = m.GameType
	stage1.Map = m.Map
	stage1.MatchID = m.MatchID
	stage1.Mode = m.Mode
	stage1.Player = m.Player
	stage1.PlayerCount = m.PlayerCount
	stage1.PlayerStats = m.PlayerStats
	stage1.PlaylistName = m.PlaylistName
	stage1.PrivateMatch = m.PrivateMatch
	stage1.RankedTeams = m.RankedTeams
	stage1.TeamCount = m.TeamCount
	stage1.UtcEndSeconds = m.UtcEndSeconds
	stage1.UtcStartSeconds = m.UtcStartSeconds
	stage1.Version = m.Version

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.FullMatchInfoResponseDataAllPlayersItems0AdditionalProperties) == 0 {
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.FullMatchInfoResponseDataAllPlayersItems0AdditionalProperties)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 {
		return additional, nil
	}

	// concatenate the 2 objects
	props[len(props)-1] = ','
	return append(props, additional[1:]...), nil
}

// Validate validates this full match info response data all players items0
func (m *FullMatchInfoResponseDataAllPlayersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePlayer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlayerStats(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FullMatchInfoResponseDataAllPlayersItems0) validatePlayer(formats strfmt.Registry) error {

	if swag.IsZero(m.Player) { // not required
		return nil
	}

	if m.Player != nil {
		if err := m.Player.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("player")
			}
			return err
		}
	}

	return nil
}

func (m *FullMatchInfoResponseDataAllPlayersItems0) validatePlayerStats(formats strfmt.Registry) error {

	if swag.IsZero(m.PlayerStats) { // not required
		return nil
	}

	if m.PlayerStats != nil {
		if err := m.PlayerStats.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("playerStats")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FullMatchInfoResponseDataAllPlayersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FullMatchInfoResponseDataAllPlayersItems0) UnmarshalBinary(b []byte) error {
	var res FullMatchInfoResponseDataAllPlayersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FullMatchInfoResponseDataAllPlayersItems0Player full match info response data all players items0 player
//
// swagger:model FullMatchInfoResponseDataAllPlayersItems0Player
type FullMatchInfoResponseDataAllPlayersItems0Player struct {

	// awards
	Awards interface{} `json:"awards,omitempty"`

	// br mission stats
	BrMissionStats *FullMatchInfoResponseDataAllPlayersItems0PlayerBrMissionStats `json:"brMissionStats,omitempty"`

	// clantag
	Clantag string `json:"clantag,omitempty"`

	// loadout
	Loadout []*FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0 `json:"loadout"`

	// rank
	Rank float64 `json:"rank,omitempty"`

	// team
	Team string `json:"team,omitempty"`

	// uno
	Uno string `json:"uno,omitempty"`

	// username
	Username string `json:"username,omitempty"`

	// full match info response data all players items0 player additional properties
	FullMatchInfoResponseDataAllPlayersItems0PlayerAdditionalProperties map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *FullMatchInfoResponseDataAllPlayersItems0Player) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// awards
		Awards interface{} `json:"awards,omitempty"`

		// br mission stats
		BrMissionStats *FullMatchInfoResponseDataAllPlayersItems0PlayerBrMissionStats `json:"brMissionStats,omitempty"`

		// clantag
		Clantag string `json:"clantag,omitempty"`

		// loadout
		Loadout []*FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0 `json:"loadout"`

		// rank
		Rank float64 `json:"rank,omitempty"`

		// team
		Team string `json:"team,omitempty"`

		// uno
		Uno string `json:"uno,omitempty"`

		// username
		Username string `json:"username,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv FullMatchInfoResponseDataAllPlayersItems0Player

	rcv.Awards = stage1.Awards
	rcv.BrMissionStats = stage1.BrMissionStats
	rcv.Clantag = stage1.Clantag
	rcv.Loadout = stage1.Loadout
	rcv.Rank = stage1.Rank
	rcv.Team = stage1.Team
	rcv.Uno = stage1.Uno
	rcv.Username = stage1.Username
	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "awards")
	delete(stage2, "brMissionStats")
	delete(stage2, "clantag")
	delete(stage2, "loadout")
	delete(stage2, "rank")
	delete(stage2, "team")
	delete(stage2, "uno")
	delete(stage2, "username")
	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.FullMatchInfoResponseDataAllPlayersItems0PlayerAdditionalProperties = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m FullMatchInfoResponseDataAllPlayersItems0Player) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// awards
		Awards interface{} `json:"awards,omitempty"`

		// br mission stats
		BrMissionStats *FullMatchInfoResponseDataAllPlayersItems0PlayerBrMissionStats `json:"brMissionStats,omitempty"`

		// clantag
		Clantag string `json:"clantag,omitempty"`

		// loadout
		Loadout []*FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0 `json:"loadout"`

		// rank
		Rank float64 `json:"rank,omitempty"`

		// team
		Team string `json:"team,omitempty"`

		// uno
		Uno string `json:"uno,omitempty"`

		// username
		Username string `json:"username,omitempty"`
	}

	stage1.Awards = m.Awards
	stage1.BrMissionStats = m.BrMissionStats
	stage1.Clantag = m.Clantag
	stage1.Loadout = m.Loadout
	stage1.Rank = m.Rank
	stage1.Team = m.Team
	stage1.Uno = m.Uno
	stage1.Username = m.Username

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.FullMatchInfoResponseDataAllPlayersItems0PlayerAdditionalProperties) == 0 {
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.FullMatchInfoResponseDataAllPlayersItems0PlayerAdditionalProperties)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 {
		return additional, nil
	}

	// concatenate the 2 objects
	props[len(props)-1] = ','
	return append(props, additional[1:]...), nil
}

// Validate validates this full match info response data all players items0 player
func (m *FullMatchInfoResponseDataAllPlayersItems0Player) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBrMissionStats(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLoadout(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FullMatchInfoResponseDataAllPlayersItems0Player) validateBrMissionStats(formats strfmt.Registry) error {

	if swag.IsZero(m.BrMissionStats) { // not required
		return nil
	}

	if m.BrMissionStats != nil {
		if err := m.BrMissionStats.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("player" + "." + "brMissionStats")
			}
			return err
		}
	}

	return nil
}

func (m *FullMatchInfoResponseDataAllPlayersItems0Player) validateLoadout(formats strfmt.Registry) error {

	if swag.IsZero(m.Loadout) { // not required
		return nil
	}

	for i := 0; i < len(m.Loadout); i++ {
		if swag.IsZero(m.Loadout[i]) { // not required
			continue
		}

		if m.Loadout[i] != nil {
			if err := m.Loadout[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("player" + "." + "loadout" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *FullMatchInfoResponseDataAllPlayersItems0Player) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FullMatchInfoResponseDataAllPlayersItems0Player) UnmarshalBinary(b []byte) error {
	var res FullMatchInfoResponseDataAllPlayersItems0Player
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FullMatchInfoResponseDataAllPlayersItems0PlayerBrMissionStats full match info response data all players items0 player br mission stats
//
// swagger:model FullMatchInfoResponseDataAllPlayersItems0PlayerBrMissionStats
type FullMatchInfoResponseDataAllPlayersItems0PlayerBrMissionStats struct {

	// mission stats by type
	MissionStatsByType interface{} `json:"missionStatsByType,omitempty"`

	// missions complete
	MissionsComplete int64 `json:"missionsComplete,omitempty"`

	// total mission weapon xp earned
	TotalMissionWeaponXpEarned float64 `json:"totalMissionWeaponXpEarned,omitempty"`

	// total mission xp earned
	TotalMissionXpEarned float64 `json:"totalMissionXpEarned,omitempty"`

	// full match info response data all players items0 player br mission stats additional properties
	FullMatchInfoResponseDataAllPlayersItems0PlayerBrMissionStatsAdditionalProperties map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerBrMissionStats) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// mission stats by type
		MissionStatsByType interface{} `json:"missionStatsByType,omitempty"`

		// missions complete
		MissionsComplete int64 `json:"missionsComplete,omitempty"`

		// total mission weapon xp earned
		TotalMissionWeaponXpEarned float64 `json:"totalMissionWeaponXpEarned,omitempty"`

		// total mission xp earned
		TotalMissionXpEarned float64 `json:"totalMissionXpEarned,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv FullMatchInfoResponseDataAllPlayersItems0PlayerBrMissionStats

	rcv.MissionStatsByType = stage1.MissionStatsByType
	rcv.MissionsComplete = stage1.MissionsComplete
	rcv.TotalMissionWeaponXpEarned = stage1.TotalMissionWeaponXpEarned
	rcv.TotalMissionXpEarned = stage1.TotalMissionXpEarned
	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "missionStatsByType")
	delete(stage2, "missionsComplete")
	delete(stage2, "totalMissionWeaponXpEarned")
	delete(stage2, "totalMissionXpEarned")
	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.FullMatchInfoResponseDataAllPlayersItems0PlayerBrMissionStatsAdditionalProperties = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m FullMatchInfoResponseDataAllPlayersItems0PlayerBrMissionStats) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// mission stats by type
		MissionStatsByType interface{} `json:"missionStatsByType,omitempty"`

		// missions complete
		MissionsComplete int64 `json:"missionsComplete,omitempty"`

		// total mission weapon xp earned
		TotalMissionWeaponXpEarned float64 `json:"totalMissionWeaponXpEarned,omitempty"`

		// total mission xp earned
		TotalMissionXpEarned float64 `json:"totalMissionXpEarned,omitempty"`
	}

	stage1.MissionStatsByType = m.MissionStatsByType
	stage1.MissionsComplete = m.MissionsComplete
	stage1.TotalMissionWeaponXpEarned = m.TotalMissionWeaponXpEarned
	stage1.TotalMissionXpEarned = m.TotalMissionXpEarned

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.FullMatchInfoResponseDataAllPlayersItems0PlayerBrMissionStatsAdditionalProperties) == 0 {
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.FullMatchInfoResponseDataAllPlayersItems0PlayerBrMissionStatsAdditionalProperties)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 {
		return additional, nil
	}

	// concatenate the 2 objects
	props[len(props)-1] = ','
	return append(props, additional[1:]...), nil
}

// Validate validates this full match info response data all players items0 player br mission stats
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerBrMissionStats) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerBrMissionStats) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerBrMissionStats) UnmarshalBinary(b []byte) error {
	var res FullMatchInfoResponseDataAllPlayersItems0PlayerBrMissionStats
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0 full match info response data all players items0 player loadout items0
//
// swagger:model FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0
type FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0 struct {

	// extra perks
	ExtraPerks []*FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0ExtraPerksItems0 `json:"extraPerks"`

	// killstreaks
	Killstreaks []*FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0KillstreaksItems0 `json:"killstreaks"`

	// lethal
	Lethal *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0Lethal `json:"lethal,omitempty"`

	// perks
	Perks []*FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PerksItems0 `json:"perks"`

	// primary weapon
	PrimaryWeapon *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeapon `json:"primaryWeapon,omitempty"`

	// secondary weapon
	SecondaryWeapon *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeapon `json:"secondaryWeapon,omitempty"`

	// tactical
	Tactical *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0Tactical `json:"tactical,omitempty"`

	// full match info response data all players items0 player loadout items0 additional properties
	FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0AdditionalProperties map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// extra perks
		ExtraPerks []*FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0ExtraPerksItems0 `json:"extraPerks"`

		// killstreaks
		Killstreaks []*FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0KillstreaksItems0 `json:"killstreaks"`

		// lethal
		Lethal *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0Lethal `json:"lethal,omitempty"`

		// perks
		Perks []*FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PerksItems0 `json:"perks"`

		// primary weapon
		PrimaryWeapon *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeapon `json:"primaryWeapon,omitempty"`

		// secondary weapon
		SecondaryWeapon *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeapon `json:"secondaryWeapon,omitempty"`

		// tactical
		Tactical *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0Tactical `json:"tactical,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0

	rcv.ExtraPerks = stage1.ExtraPerks
	rcv.Killstreaks = stage1.Killstreaks
	rcv.Lethal = stage1.Lethal
	rcv.Perks = stage1.Perks
	rcv.PrimaryWeapon = stage1.PrimaryWeapon
	rcv.SecondaryWeapon = stage1.SecondaryWeapon
	rcv.Tactical = stage1.Tactical
	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "extraPerks")
	delete(stage2, "killstreaks")
	delete(stage2, "lethal")
	delete(stage2, "perks")
	delete(stage2, "primaryWeapon")
	delete(stage2, "secondaryWeapon")
	delete(stage2, "tactical")
	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0AdditionalProperties = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// extra perks
		ExtraPerks []*FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0ExtraPerksItems0 `json:"extraPerks"`

		// killstreaks
		Killstreaks []*FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0KillstreaksItems0 `json:"killstreaks"`

		// lethal
		Lethal *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0Lethal `json:"lethal,omitempty"`

		// perks
		Perks []*FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PerksItems0 `json:"perks"`

		// primary weapon
		PrimaryWeapon *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeapon `json:"primaryWeapon,omitempty"`

		// secondary weapon
		SecondaryWeapon *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeapon `json:"secondaryWeapon,omitempty"`

		// tactical
		Tactical *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0Tactical `json:"tactical,omitempty"`
	}

	stage1.ExtraPerks = m.ExtraPerks
	stage1.Killstreaks = m.Killstreaks
	stage1.Lethal = m.Lethal
	stage1.Perks = m.Perks
	stage1.PrimaryWeapon = m.PrimaryWeapon
	stage1.SecondaryWeapon = m.SecondaryWeapon
	stage1.Tactical = m.Tactical

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0AdditionalProperties) == 0 {
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0AdditionalProperties)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 {
		return additional, nil
	}

	// concatenate the 2 objects
	props[len(props)-1] = ','
	return append(props, additional[1:]...), nil
}

// Validate validates this full match info response data all players items0 player loadout items0
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateExtraPerks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKillstreaks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLethal(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePerks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrimaryWeapon(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecondaryWeapon(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTactical(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0) validateExtraPerks(formats strfmt.Registry) error {

	if swag.IsZero(m.ExtraPerks) { // not required
		return nil
	}

	for i := 0; i < len(m.ExtraPerks); i++ {
		if swag.IsZero(m.ExtraPerks[i]) { // not required
			continue
		}

		if m.ExtraPerks[i] != nil {
			if err := m.ExtraPerks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("extraPerks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0) validateKillstreaks(formats strfmt.Registry) error {

	if swag.IsZero(m.Killstreaks) { // not required
		return nil
	}

	for i := 0; i < len(m.Killstreaks); i++ {
		if swag.IsZero(m.Killstreaks[i]) { // not required
			continue
		}

		if m.Killstreaks[i] != nil {
			if err := m.Killstreaks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("killstreaks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0) validateLethal(formats strfmt.Registry) error {

	if swag.IsZero(m.Lethal) { // not required
		return nil
	}

	if m.Lethal != nil {
		if err := m.Lethal.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("lethal")
			}
			return err
		}
	}

	return nil
}

func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0) validatePerks(formats strfmt.Registry) error {

	if swag.IsZero(m.Perks) { // not required
		return nil
	}

	for i := 0; i < len(m.Perks); i++ {
		if swag.IsZero(m.Perks[i]) { // not required
			continue
		}

		if m.Perks[i] != nil {
			if err := m.Perks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("perks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0) validatePrimaryWeapon(formats strfmt.Registry) error {

	if swag.IsZero(m.PrimaryWeapon) { // not required
		return nil
	}

	if m.PrimaryWeapon != nil {
		if err := m.PrimaryWeapon.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("primaryWeapon")
			}
			return err
		}
	}

	return nil
}

func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0) validateSecondaryWeapon(formats strfmt.Registry) error {

	if swag.IsZero(m.SecondaryWeapon) { // not required
		return nil
	}

	if m.SecondaryWeapon != nil {
		if err := m.SecondaryWeapon.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("secondaryWeapon")
			}
			return err
		}
	}

	return nil
}

func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0) validateTactical(formats strfmt.Registry) error {

	if swag.IsZero(m.Tactical) { // not required
		return nil
	}

	if m.Tactical != nil {
		if err := m.Tactical.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tactical")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0) UnmarshalBinary(b []byte) error {
	var res FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0ExtraPerksItems0 full match info response data all players items0 player loadout items0 extra perks items0
//
// swagger:model FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0ExtraPerksItems0
type FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0ExtraPerksItems0 struct {

	// image
	Image interface{} `json:"image,omitempty"`

	// image main Ui
	ImageMainUI interface{} `json:"imageMainUi,omitempty"`

	// image progression
	ImageProgression interface{} `json:"imageProgression,omitempty"`

	// label
	Label interface{} `json:"label,omitempty"`

	// name
	Name string `json:"name,omitempty"`

	// full match info response data all players items0 player loadout items0 extra perks items0 additional properties
	FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0ExtraPerksItems0AdditionalProperties map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0ExtraPerksItems0) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// image
		Image interface{} `json:"image,omitempty"`

		// image main Ui
		ImageMainUI interface{} `json:"imageMainUi,omitempty"`

		// image progression
		ImageProgression interface{} `json:"imageProgression,omitempty"`

		// label
		Label interface{} `json:"label,omitempty"`

		// name
		Name string `json:"name,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0ExtraPerksItems0

	rcv.Image = stage1.Image
	rcv.ImageMainUI = stage1.ImageMainUI
	rcv.ImageProgression = stage1.ImageProgression
	rcv.Label = stage1.Label
	rcv.Name = stage1.Name
	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "image")
	delete(stage2, "imageMainUi")
	delete(stage2, "imageProgression")
	delete(stage2, "label")
	delete(stage2, "name")
	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0ExtraPerksItems0AdditionalProperties = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0ExtraPerksItems0) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// image
		Image interface{} `json:"image,omitempty"`

		// image main Ui
		ImageMainUI interface{} `json:"imageMainUi,omitempty"`

		// image progression
		ImageProgression interface{} `json:"imageProgression,omitempty"`

		// label
		Label interface{} `json:"label,omitempty"`

		// name
		Name string `json:"name,omitempty"`
	}

	stage1.Image = m.Image
	stage1.ImageMainUI = m.ImageMainUI
	stage1.ImageProgression = m.ImageProgression
	stage1.Label = m.Label
	stage1.Name = m.Name

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0ExtraPerksItems0AdditionalProperties) == 0 {
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0ExtraPerksItems0AdditionalProperties)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 {
		return additional, nil
	}

	// concatenate the 2 objects
	props[len(props)-1] = ','
	return append(props, additional[1:]...), nil
}

// Validate validates this full match info response data all players items0 player loadout items0 extra perks items0
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0ExtraPerksItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0ExtraPerksItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0ExtraPerksItems0) UnmarshalBinary(b []byte) error {
	var res FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0ExtraPerksItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0KillstreaksItems0 full match info response data all players items0 player loadout items0 killstreaks items0
//
// swagger:model FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0KillstreaksItems0
type FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0KillstreaksItems0 struct {

	// label
	Label interface{} `json:"label,omitempty"`

	// name
	Name string `json:"name,omitempty"`

	// full match info response data all players items0 player loadout items0 killstreaks items0 additional properties
	FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0KillstreaksItems0AdditionalProperties map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0KillstreaksItems0) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// label
		Label interface{} `json:"label,omitempty"`

		// name
		Name string `json:"name,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0KillstreaksItems0

	rcv.Label = stage1.Label
	rcv.Name = stage1.Name
	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "label")
	delete(stage2, "name")
	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0KillstreaksItems0AdditionalProperties = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0KillstreaksItems0) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// label
		Label interface{} `json:"label,omitempty"`

		// name
		Name string `json:"name,omitempty"`
	}

	stage1.Label = m.Label
	stage1.Name = m.Name

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0KillstreaksItems0AdditionalProperties) == 0 {
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0KillstreaksItems0AdditionalProperties)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 {
		return additional, nil
	}

	// concatenate the 2 objects
	props[len(props)-1] = ','
	return append(props, additional[1:]...), nil
}

// Validate validates this full match info response data all players items0 player loadout items0 killstreaks items0
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0KillstreaksItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0KillstreaksItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0KillstreaksItems0) UnmarshalBinary(b []byte) error {
	var res FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0KillstreaksItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0Lethal full match info response data all players items0 player loadout items0 lethal
//
// swagger:model FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0Lethal
type FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0Lethal struct {

	// image
	Image interface{} `json:"image,omitempty"`

	// image large
	ImageLarge interface{} `json:"imageLarge,omitempty"`

	// label
	Label interface{} `json:"label,omitempty"`

	// name
	Name string `json:"name,omitempty"`

	// progression image
	ProgressionImage interface{} `json:"progressionImage,omitempty"`

	// full match info response data all players items0 player loadout items0 lethal additional properties
	FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0LethalAdditionalProperties map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0Lethal) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// image
		Image interface{} `json:"image,omitempty"`

		// image large
		ImageLarge interface{} `json:"imageLarge,omitempty"`

		// label
		Label interface{} `json:"label,omitempty"`

		// name
		Name string `json:"name,omitempty"`

		// progression image
		ProgressionImage interface{} `json:"progressionImage,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0Lethal

	rcv.Image = stage1.Image
	rcv.ImageLarge = stage1.ImageLarge
	rcv.Label = stage1.Label
	rcv.Name = stage1.Name
	rcv.ProgressionImage = stage1.ProgressionImage
	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "image")
	delete(stage2, "imageLarge")
	delete(stage2, "label")
	delete(stage2, "name")
	delete(stage2, "progressionImage")
	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0LethalAdditionalProperties = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0Lethal) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// image
		Image interface{} `json:"image,omitempty"`

		// image large
		ImageLarge interface{} `json:"imageLarge,omitempty"`

		// label
		Label interface{} `json:"label,omitempty"`

		// name
		Name string `json:"name,omitempty"`

		// progression image
		ProgressionImage interface{} `json:"progressionImage,omitempty"`
	}

	stage1.Image = m.Image
	stage1.ImageLarge = m.ImageLarge
	stage1.Label = m.Label
	stage1.Name = m.Name
	stage1.ProgressionImage = m.ProgressionImage

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0LethalAdditionalProperties) == 0 {
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0LethalAdditionalProperties)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 {
		return additional, nil
	}

	// concatenate the 2 objects
	props[len(props)-1] = ','
	return append(props, additional[1:]...), nil
}

// Validate validates this full match info response data all players items0 player loadout items0 lethal
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0Lethal) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0Lethal) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0Lethal) UnmarshalBinary(b []byte) error {
	var res FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0Lethal
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PerksItems0 full match info response data all players items0 player loadout items0 perks items0
//
// swagger:model FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PerksItems0
type FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PerksItems0 struct {

	// image
	Image interface{} `json:"image,omitempty"`

	// image main Ui
	ImageMainUI interface{} `json:"imageMainUi,omitempty"`

	// image progression
	ImageProgression interface{} `json:"imageProgression,omitempty"`

	// label
	Label interface{} `json:"label,omitempty"`

	// name
	Name string `json:"name,omitempty"`

	// full match info response data all players items0 player loadout items0 perks items0 additional properties
	FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PerksItems0AdditionalProperties map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PerksItems0) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// image
		Image interface{} `json:"image,omitempty"`

		// image main Ui
		ImageMainUI interface{} `json:"imageMainUi,omitempty"`

		// image progression
		ImageProgression interface{} `json:"imageProgression,omitempty"`

		// label
		Label interface{} `json:"label,omitempty"`

		// name
		Name string `json:"name,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PerksItems0

	rcv.Image = stage1.Image
	rcv.ImageMainUI = stage1.ImageMainUI
	rcv.ImageProgression = stage1.ImageProgression
	rcv.Label = stage1.Label
	rcv.Name = stage1.Name
	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "image")
	delete(stage2, "imageMainUi")
	delete(stage2, "imageProgression")
	delete(stage2, "label")
	delete(stage2, "name")
	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PerksItems0AdditionalProperties = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PerksItems0) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// image
		Image interface{} `json:"image,omitempty"`

		// image main Ui
		ImageMainUI interface{} `json:"imageMainUi,omitempty"`

		// image progression
		ImageProgression interface{} `json:"imageProgression,omitempty"`

		// label
		Label interface{} `json:"label,omitempty"`

		// name
		Name string `json:"name,omitempty"`
	}

	stage1.Image = m.Image
	stage1.ImageMainUI = m.ImageMainUI
	stage1.ImageProgression = m.ImageProgression
	stage1.Label = m.Label
	stage1.Name = m.Name

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PerksItems0AdditionalProperties) == 0 {
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PerksItems0AdditionalProperties)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 {
		return additional, nil
	}

	// concatenate the 2 objects
	props[len(props)-1] = ','
	return append(props, additional[1:]...), nil
}

// Validate validates this full match info response data all players items0 player loadout items0 perks items0
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PerksItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PerksItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PerksItems0) UnmarshalBinary(b []byte) error {
	var res FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PerksItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeapon full match info response data all players items0 player loadout items0 primary weapon
//
// swagger:model FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeapon
type FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeapon struct {

	// attachments
	Attachments []*FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeaponAttachmentsItems0 `json:"attachments"`

	// image icon
	ImageIcon interface{} `json:"imageIcon,omitempty"`

	// image loot
	ImageLoot interface{} `json:"imageLoot,omitempty"`

	// label
	Label interface{} `json:"label,omitempty"`

	// name
	Name string `json:"name,omitempty"`

	// variant
	Variant string `json:"variant,omitempty"`

	// full match info response data all players items0 player loadout items0 primary weapon additional properties
	FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeaponAdditionalProperties map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeapon) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// attachments
		Attachments []*FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeaponAttachmentsItems0 `json:"attachments"`

		// image icon
		ImageIcon interface{} `json:"imageIcon,omitempty"`

		// image loot
		ImageLoot interface{} `json:"imageLoot,omitempty"`

		// label
		Label interface{} `json:"label,omitempty"`

		// name
		Name string `json:"name,omitempty"`

		// variant
		Variant string `json:"variant,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeapon

	rcv.Attachments = stage1.Attachments
	rcv.ImageIcon = stage1.ImageIcon
	rcv.ImageLoot = stage1.ImageLoot
	rcv.Label = stage1.Label
	rcv.Name = stage1.Name
	rcv.Variant = stage1.Variant
	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "attachments")
	delete(stage2, "imageIcon")
	delete(stage2, "imageLoot")
	delete(stage2, "label")
	delete(stage2, "name")
	delete(stage2, "variant")
	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeaponAdditionalProperties = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeapon) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// attachments
		Attachments []*FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeaponAttachmentsItems0 `json:"attachments"`

		// image icon
		ImageIcon interface{} `json:"imageIcon,omitempty"`

		// image loot
		ImageLoot interface{} `json:"imageLoot,omitempty"`

		// label
		Label interface{} `json:"label,omitempty"`

		// name
		Name string `json:"name,omitempty"`

		// variant
		Variant string `json:"variant,omitempty"`
	}

	stage1.Attachments = m.Attachments
	stage1.ImageIcon = m.ImageIcon
	stage1.ImageLoot = m.ImageLoot
	stage1.Label = m.Label
	stage1.Name = m.Name
	stage1.Variant = m.Variant

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeaponAdditionalProperties) == 0 {
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeaponAdditionalProperties)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 {
		return additional, nil
	}

	// concatenate the 2 objects
	props[len(props)-1] = ','
	return append(props, additional[1:]...), nil
}

// Validate validates this full match info response data all players items0 player loadout items0 primary weapon
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeapon) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAttachments(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeapon) validateAttachments(formats strfmt.Registry) error {

	if swag.IsZero(m.Attachments) { // not required
		return nil
	}

	for i := 0; i < len(m.Attachments); i++ {
		if swag.IsZero(m.Attachments[i]) { // not required
			continue
		}

		if m.Attachments[i] != nil {
			if err := m.Attachments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("primaryWeapon" + "." + "attachments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeapon) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeapon) UnmarshalBinary(b []byte) error {
	var res FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeapon
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeaponAttachmentsItems0 full match info response data all players items0 player loadout items0 primary weapon attachments items0
//
// swagger:model FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeaponAttachmentsItems0
type FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeaponAttachmentsItems0 struct {

	// category
	Category interface{} `json:"category,omitempty"`

	// image
	Image interface{} `json:"image,omitempty"`

	// label
	Label interface{} `json:"label,omitempty"`

	// name
	Name string `json:"name,omitempty"`

	// full match info response data all players items0 player loadout items0 primary weapon attachments items0 additional properties
	FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeaponAttachmentsItems0AdditionalProperties map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeaponAttachmentsItems0) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// category
		Category interface{} `json:"category,omitempty"`

		// image
		Image interface{} `json:"image,omitempty"`

		// label
		Label interface{} `json:"label,omitempty"`

		// name
		Name string `json:"name,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeaponAttachmentsItems0

	rcv.Category = stage1.Category
	rcv.Image = stage1.Image
	rcv.Label = stage1.Label
	rcv.Name = stage1.Name
	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "category")
	delete(stage2, "image")
	delete(stage2, "label")
	delete(stage2, "name")
	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeaponAttachmentsItems0AdditionalProperties = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeaponAttachmentsItems0) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// category
		Category interface{} `json:"category,omitempty"`

		// image
		Image interface{} `json:"image,omitempty"`

		// label
		Label interface{} `json:"label,omitempty"`

		// name
		Name string `json:"name,omitempty"`
	}

	stage1.Category = m.Category
	stage1.Image = m.Image
	stage1.Label = m.Label
	stage1.Name = m.Name

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeaponAttachmentsItems0AdditionalProperties) == 0 {
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeaponAttachmentsItems0AdditionalProperties)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 {
		return additional, nil
	}

	// concatenate the 2 objects
	props[len(props)-1] = ','
	return append(props, additional[1:]...), nil
}

// Validate validates this full match info response data all players items0 player loadout items0 primary weapon attachments items0
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeaponAttachmentsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeaponAttachmentsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeaponAttachmentsItems0) UnmarshalBinary(b []byte) error {
	var res FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0PrimaryWeaponAttachmentsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeapon full match info response data all players items0 player loadout items0 secondary weapon
//
// swagger:model FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeapon
type FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeapon struct {

	// attachments
	Attachments []*FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeaponAttachmentsItems0 `json:"attachments"`

	// image icon
	ImageIcon interface{} `json:"imageIcon,omitempty"`

	// image loot
	ImageLoot interface{} `json:"imageLoot,omitempty"`

	// label
	Label interface{} `json:"label,omitempty"`

	// name
	Name string `json:"name,omitempty"`

	// variant
	Variant string `json:"variant,omitempty"`

	// full match info response data all players items0 player loadout items0 secondary weapon additional properties
	FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeaponAdditionalProperties map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeapon) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// attachments
		Attachments []*FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeaponAttachmentsItems0 `json:"attachments"`

		// image icon
		ImageIcon interface{} `json:"imageIcon,omitempty"`

		// image loot
		ImageLoot interface{} `json:"imageLoot,omitempty"`

		// label
		Label interface{} `json:"label,omitempty"`

		// name
		Name string `json:"name,omitempty"`

		// variant
		Variant string `json:"variant,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeapon

	rcv.Attachments = stage1.Attachments
	rcv.ImageIcon = stage1.ImageIcon
	rcv.ImageLoot = stage1.ImageLoot
	rcv.Label = stage1.Label
	rcv.Name = stage1.Name
	rcv.Variant = stage1.Variant
	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "attachments")
	delete(stage2, "imageIcon")
	delete(stage2, "imageLoot")
	delete(stage2, "label")
	delete(stage2, "name")
	delete(stage2, "variant")
	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeaponAdditionalProperties = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeapon) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// attachments
		Attachments []*FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeaponAttachmentsItems0 `json:"attachments"`

		// image icon
		ImageIcon interface{} `json:"imageIcon,omitempty"`

		// image loot
		ImageLoot interface{} `json:"imageLoot,omitempty"`

		// label
		Label interface{} `json:"label,omitempty"`

		// name
		Name string `json:"name,omitempty"`

		// variant
		Variant string `json:"variant,omitempty"`
	}

	stage1.Attachments = m.Attachments
	stage1.ImageIcon = m.ImageIcon
	stage1.ImageLoot = m.ImageLoot
	stage1.Label = m.Label
	stage1.Name = m.Name
	stage1.Variant = m.Variant

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeaponAdditionalProperties) == 0 {
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeaponAdditionalProperties)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 {
		return additional, nil
	}

	// concatenate the 2 objects
	props[len(props)-1] = ','
	return append(props, additional[1:]...), nil
}

// Validate validates this full match info response data all players items0 player loadout items0 secondary weapon
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeapon) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAttachments(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeapon) validateAttachments(formats strfmt.Registry) error {

	if swag.IsZero(m.Attachments) { // not required
		return nil
	}

	for i := 0; i < len(m.Attachments); i++ {
		if swag.IsZero(m.Attachments[i]) { // not required
			continue
		}

		if m.Attachments[i] != nil {
			if err := m.Attachments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("secondaryWeapon" + "." + "attachments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeapon) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeapon) UnmarshalBinary(b []byte) error {
	var res FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeapon
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeaponAttachmentsItems0 full match info response data all players items0 player loadout items0 secondary weapon attachments items0
//
// swagger:model FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeaponAttachmentsItems0
type FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeaponAttachmentsItems0 struct {

	// category
	Category interface{} `json:"category,omitempty"`

	// image
	Image interface{} `json:"image,omitempty"`

	// label
	Label interface{} `json:"label,omitempty"`

	// name
	Name string `json:"name,omitempty"`

	// full match info response data all players items0 player loadout items0 secondary weapon attachments items0 additional properties
	FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeaponAttachmentsItems0AdditionalProperties map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeaponAttachmentsItems0) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// category
		Category interface{} `json:"category,omitempty"`

		// image
		Image interface{} `json:"image,omitempty"`

		// label
		Label interface{} `json:"label,omitempty"`

		// name
		Name string `json:"name,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeaponAttachmentsItems0

	rcv.Category = stage1.Category
	rcv.Image = stage1.Image
	rcv.Label = stage1.Label
	rcv.Name = stage1.Name
	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "category")
	delete(stage2, "image")
	delete(stage2, "label")
	delete(stage2, "name")
	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeaponAttachmentsItems0AdditionalProperties = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeaponAttachmentsItems0) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// category
		Category interface{} `json:"category,omitempty"`

		// image
		Image interface{} `json:"image,omitempty"`

		// label
		Label interface{} `json:"label,omitempty"`

		// name
		Name string `json:"name,omitempty"`
	}

	stage1.Category = m.Category
	stage1.Image = m.Image
	stage1.Label = m.Label
	stage1.Name = m.Name

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeaponAttachmentsItems0AdditionalProperties) == 0 {
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeaponAttachmentsItems0AdditionalProperties)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 {
		return additional, nil
	}

	// concatenate the 2 objects
	props[len(props)-1] = ','
	return append(props, additional[1:]...), nil
}

// Validate validates this full match info response data all players items0 player loadout items0 secondary weapon attachments items0
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeaponAttachmentsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeaponAttachmentsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeaponAttachmentsItems0) UnmarshalBinary(b []byte) error {
	var res FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0SecondaryWeaponAttachmentsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0Tactical full match info response data all players items0 player loadout items0 tactical
//
// swagger:model FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0Tactical
type FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0Tactical struct {

	// image
	Image interface{} `json:"image,omitempty"`

	// image large
	ImageLarge interface{} `json:"imageLarge,omitempty"`

	// label
	Label interface{} `json:"label,omitempty"`

	// name
	Name string `json:"name,omitempty"`

	// progression image
	ProgressionImage interface{} `json:"progressionImage,omitempty"`

	// full match info response data all players items0 player loadout items0 tactical additional properties
	FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0TacticalAdditionalProperties map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0Tactical) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// image
		Image interface{} `json:"image,omitempty"`

		// image large
		ImageLarge interface{} `json:"imageLarge,omitempty"`

		// label
		Label interface{} `json:"label,omitempty"`

		// name
		Name string `json:"name,omitempty"`

		// progression image
		ProgressionImage interface{} `json:"progressionImage,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0Tactical

	rcv.Image = stage1.Image
	rcv.ImageLarge = stage1.ImageLarge
	rcv.Label = stage1.Label
	rcv.Name = stage1.Name
	rcv.ProgressionImage = stage1.ProgressionImage
	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "image")
	delete(stage2, "imageLarge")
	delete(stage2, "label")
	delete(stage2, "name")
	delete(stage2, "progressionImage")
	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0TacticalAdditionalProperties = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0Tactical) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// image
		Image interface{} `json:"image,omitempty"`

		// image large
		ImageLarge interface{} `json:"imageLarge,omitempty"`

		// label
		Label interface{} `json:"label,omitempty"`

		// name
		Name string `json:"name,omitempty"`

		// progression image
		ProgressionImage interface{} `json:"progressionImage,omitempty"`
	}

	stage1.Image = m.Image
	stage1.ImageLarge = m.ImageLarge
	stage1.Label = m.Label
	stage1.Name = m.Name
	stage1.ProgressionImage = m.ProgressionImage

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0TacticalAdditionalProperties) == 0 {
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0TacticalAdditionalProperties)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 {
		return additional, nil
	}

	// concatenate the 2 objects
	props[len(props)-1] = ','
	return append(props, additional[1:]...), nil
}

// Validate validates this full match info response data all players items0 player loadout items0 tactical
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0Tactical) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0Tactical) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0Tactical) UnmarshalBinary(b []byte) error {
	var res FullMatchInfoResponseDataAllPlayersItems0PlayerLoadoutItems0Tactical
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// FullMatchInfoResponseDataAllPlayersItems0PlayerStats full match info response data all players items0 player stats
//
// swagger:model FullMatchInfoResponseDataAllPlayersItems0PlayerStats
type FullMatchInfoResponseDataAllPlayersItems0PlayerStats struct {

	// assists
	Assists float64 `json:"assists,omitempty"`

	// bonus xp
	BonusXp float64 `json:"bonusXp,omitempty"`

	// challenge xp
	ChallengeXp float64 `json:"challengeXp,omitempty"`

	// damage done
	DamageDone float64 `json:"damageDone,omitempty"`

	// damage taken
	DamageTaken float64 `json:"damageTaken,omitempty"`

	// deaths
	Deaths float64 `json:"deaths,omitempty"`

	// distance traveled
	DistanceTraveled float64 `json:"distanceTraveled,omitempty"`

	// executions
	Executions float64 `json:"executions,omitempty"`

	// gulag deaths
	GulagDeaths float64 `json:"gulagDeaths,omitempty"`

	// gulag kills
	GulagKills float64 `json:"gulagKills,omitempty"`

	// headshots
	Headshots float64 `json:"headshots,omitempty"`

	// kd ratio
	KdRatio float64 `json:"kdRatio,omitempty"`

	// kills
	Kills float64 `json:"kills,omitempty"`

	// longest streak
	LongestStreak float64 `json:"longestStreak,omitempty"`

	// match xp
	MatchXp float64 `json:"matchXp,omitempty"`

	// medal xp
	MedalXp float64 `json:"medalXp,omitempty"`

	// misc xp
	MiscXp float64 `json:"miscXp,omitempty"`

	// nearmisses
	Nearmisses float64 `json:"nearmisses,omitempty"`

	// objective br cache open
	ObjectiveBrCacheOpen float64 `json:"objectiveBrCacheOpen,omitempty"`

	// objective br down enemy circle1
	ObjectiveBrDownEnemyCircle1 float64 `json:"objectiveBrDownEnemyCircle1,omitempty"`

	// objective br kiosk buy
	ObjectiveBrKioskBuy float64 `json:"objectiveBrKioskBuy,omitempty"`

	// objective br mission pickup tablet
	ObjectiveBrMissionPickupTablet float64 `json:"objectiveBrMissionPickupTablet,omitempty"`

	// objective last stand kill
	ObjectiveLastStandKill float64 `json:"objectiveLastStandKill,omitempty"`

	// percent time moving
	PercentTimeMoving float64 `json:"percentTimeMoving,omitempty"`

	// rank
	Rank float64 `json:"rank,omitempty"`

	// score
	Score float64 `json:"score,omitempty"`

	// score per minute
	ScorePerMinute float64 `json:"scorePerMinute,omitempty"`

	// score xp
	ScoreXp float64 `json:"scoreXp,omitempty"`

	// team placement
	TeamPlacement float64 `json:"teamPlacement,omitempty"`

	// team survival time
	TeamSurvivalTime float64 `json:"teamSurvivalTime,omitempty"`

	// time played
	TimePlayed float64 `json:"timePlayed,omitempty"`

	// total xp
	TotalXp float64 `json:"totalXp,omitempty"`

	// wall bangs
	WallBangs float64 `json:"wallBangs,omitempty"`

	// full match info response data all players items0 player stats additional properties
	FullMatchInfoResponseDataAllPlayersItems0PlayerStatsAdditionalProperties map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerStats) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// assists
		Assists float64 `json:"assists,omitempty"`

		// bonus xp
		BonusXp float64 `json:"bonusXp,omitempty"`

		// challenge xp
		ChallengeXp float64 `json:"challengeXp,omitempty"`

		// damage done
		DamageDone float64 `json:"damageDone,omitempty"`

		// damage taken
		DamageTaken float64 `json:"damageTaken,omitempty"`

		// deaths
		Deaths float64 `json:"deaths,omitempty"`

		// distance traveled
		DistanceTraveled float64 `json:"distanceTraveled,omitempty"`

		// executions
		Executions float64 `json:"executions,omitempty"`

		// gulag deaths
		GulagDeaths float64 `json:"gulagDeaths,omitempty"`

		// gulag kills
		GulagKills float64 `json:"gulagKills,omitempty"`

		// headshots
		Headshots float64 `json:"headshots,omitempty"`

		// kd ratio
		KdRatio float64 `json:"kdRatio,omitempty"`

		// kills
		Kills float64 `json:"kills,omitempty"`

		// longest streak
		LongestStreak float64 `json:"longestStreak,omitempty"`

		// match xp
		MatchXp float64 `json:"matchXp,omitempty"`

		// medal xp
		MedalXp float64 `json:"medalXp,omitempty"`

		// misc xp
		MiscXp float64 `json:"miscXp,omitempty"`

		// nearmisses
		Nearmisses float64 `json:"nearmisses,omitempty"`

		// objective br cache open
		ObjectiveBrCacheOpen float64 `json:"objectiveBrCacheOpen,omitempty"`

		// objective br down enemy circle1
		ObjectiveBrDownEnemyCircle1 float64 `json:"objectiveBrDownEnemyCircle1,omitempty"`

		// objective br kiosk buy
		ObjectiveBrKioskBuy float64 `json:"objectiveBrKioskBuy,omitempty"`

		// objective br mission pickup tablet
		ObjectiveBrMissionPickupTablet float64 `json:"objectiveBrMissionPickupTablet,omitempty"`

		// objective last stand kill
		ObjectiveLastStandKill float64 `json:"objectiveLastStandKill,omitempty"`

		// percent time moving
		PercentTimeMoving float64 `json:"percentTimeMoving,omitempty"`

		// rank
		Rank float64 `json:"rank,omitempty"`

		// score
		Score float64 `json:"score,omitempty"`

		// score per minute
		ScorePerMinute float64 `json:"scorePerMinute,omitempty"`

		// score xp
		ScoreXp float64 `json:"scoreXp,omitempty"`

		// team placement
		TeamPlacement float64 `json:"teamPlacement,omitempty"`

		// team survival time
		TeamSurvivalTime float64 `json:"teamSurvivalTime,omitempty"`

		// time played
		TimePlayed float64 `json:"timePlayed,omitempty"`

		// total xp
		TotalXp float64 `json:"totalXp,omitempty"`

		// wall bangs
		WallBangs float64 `json:"wallBangs,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv FullMatchInfoResponseDataAllPlayersItems0PlayerStats

	rcv.Assists = stage1.Assists
	rcv.BonusXp = stage1.BonusXp
	rcv.ChallengeXp = stage1.ChallengeXp
	rcv.DamageDone = stage1.DamageDone
	rcv.DamageTaken = stage1.DamageTaken
	rcv.Deaths = stage1.Deaths
	rcv.DistanceTraveled = stage1.DistanceTraveled
	rcv.Executions = stage1.Executions
	rcv.GulagDeaths = stage1.GulagDeaths
	rcv.GulagKills = stage1.GulagKills
	rcv.Headshots = stage1.Headshots
	rcv.KdRatio = stage1.KdRatio
	rcv.Kills = stage1.Kills
	rcv.LongestStreak = stage1.LongestStreak
	rcv.MatchXp = stage1.MatchXp
	rcv.MedalXp = stage1.MedalXp
	rcv.MiscXp = stage1.MiscXp
	rcv.Nearmisses = stage1.Nearmisses
	rcv.ObjectiveBrCacheOpen = stage1.ObjectiveBrCacheOpen
	rcv.ObjectiveBrDownEnemyCircle1 = stage1.ObjectiveBrDownEnemyCircle1
	rcv.ObjectiveBrKioskBuy = stage1.ObjectiveBrKioskBuy
	rcv.ObjectiveBrMissionPickupTablet = stage1.ObjectiveBrMissionPickupTablet
	rcv.ObjectiveLastStandKill = stage1.ObjectiveLastStandKill
	rcv.PercentTimeMoving = stage1.PercentTimeMoving
	rcv.Rank = stage1.Rank
	rcv.Score = stage1.Score
	rcv.ScorePerMinute = stage1.ScorePerMinute
	rcv.ScoreXp = stage1.ScoreXp
	rcv.TeamPlacement = stage1.TeamPlacement
	rcv.TeamSurvivalTime = stage1.TeamSurvivalTime
	rcv.TimePlayed = stage1.TimePlayed
	rcv.TotalXp = stage1.TotalXp
	rcv.WallBangs = stage1.WallBangs
	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "assists")
	delete(stage2, "bonusXp")
	delete(stage2, "challengeXp")
	delete(stage2, "damageDone")
	delete(stage2, "damageTaken")
	delete(stage2, "deaths")
	delete(stage2, "distanceTraveled")
	delete(stage2, "executions")
	delete(stage2, "gulagDeaths")
	delete(stage2, "gulagKills")
	delete(stage2, "headshots")
	delete(stage2, "kdRatio")
	delete(stage2, "kills")
	delete(stage2, "longestStreak")
	delete(stage2, "matchXp")
	delete(stage2, "medalXp")
	delete(stage2, "miscXp")
	delete(stage2, "nearmisses")
	delete(stage2, "objectiveBrCacheOpen")
	delete(stage2, "objectiveBrDownEnemyCircle1")
	delete(stage2, "objectiveBrKioskBuy")
	delete(stage2, "objectiveBrMissionPickupTablet")
	delete(stage2, "objectiveLastStandKill")
	delete(stage2, "percentTimeMoving")
	delete(stage2, "rank")
	delete(stage2, "score")
	delete(stage2, "scorePerMinute")
	delete(stage2, "scoreXp")
	delete(stage2, "teamPlacement")
	delete(stage2, "teamSurvivalTime")
	delete(stage2, "timePlayed")
	delete(stage2, "totalXp")
	delete(stage2, "wallBangs")
	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.FullMatchInfoResponseDataAllPlayersItems0PlayerStatsAdditionalProperties = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m FullMatchInfoResponseDataAllPlayersItems0PlayerStats) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// assists
		Assists float64 `json:"assists,omitempty"`

		// bonus xp
		BonusXp float64 `json:"bonusXp,omitempty"`

		// challenge xp
		ChallengeXp float64 `json:"challengeXp,omitempty"`

		// damage done
		DamageDone float64 `json:"damageDone,omitempty"`

		// damage taken
		DamageTaken float64 `json:"damageTaken,omitempty"`

		// deaths
		Deaths float64 `json:"deaths,omitempty"`

		// distance traveled
		DistanceTraveled float64 `json:"distanceTraveled,omitempty"`

		// executions
		Executions float64 `json:"executions,omitempty"`

		// gulag deaths
		GulagDeaths float64 `json:"gulagDeaths,omitempty"`

		// gulag kills
		GulagKills float64 `json:"gulagKills,omitempty"`

		// headshots
		Headshots float64 `json:"headshots,omitempty"`

		// kd ratio
		KdRatio float64 `json:"kdRatio,omitempty"`

		// kills
		Kills float64 `json:"kills,omitempty"`

		// longest streak
		LongestStreak float64 `json:"longestStreak,omitempty"`

		// match xp
		MatchXp float64 `json:"matchXp,omitempty"`

		// medal xp
		MedalXp float64 `json:"medalXp,omitempty"`

		// misc xp
		MiscXp float64 `json:"miscXp,omitempty"`

		// nearmisses
		Nearmisses float64 `json:"nearmisses,omitempty"`

		// objective br cache open
		ObjectiveBrCacheOpen float64 `json:"objectiveBrCacheOpen,omitempty"`

		// objective br down enemy circle1
		ObjectiveBrDownEnemyCircle1 float64 `json:"objectiveBrDownEnemyCircle1,omitempty"`

		// objective br kiosk buy
		ObjectiveBrKioskBuy float64 `json:"objectiveBrKioskBuy,omitempty"`

		// objective br mission pickup tablet
		ObjectiveBrMissionPickupTablet float64 `json:"objectiveBrMissionPickupTablet,omitempty"`

		// objective last stand kill
		ObjectiveLastStandKill float64 `json:"objectiveLastStandKill,omitempty"`

		// percent time moving
		PercentTimeMoving float64 `json:"percentTimeMoving,omitempty"`

		// rank
		Rank float64 `json:"rank,omitempty"`

		// score
		Score float64 `json:"score,omitempty"`

		// score per minute
		ScorePerMinute float64 `json:"scorePerMinute,omitempty"`

		// score xp
		ScoreXp float64 `json:"scoreXp,omitempty"`

		// team placement
		TeamPlacement float64 `json:"teamPlacement,omitempty"`

		// team survival time
		TeamSurvivalTime float64 `json:"teamSurvivalTime,omitempty"`

		// time played
		TimePlayed float64 `json:"timePlayed,omitempty"`

		// total xp
		TotalXp float64 `json:"totalXp,omitempty"`

		// wall bangs
		WallBangs float64 `json:"wallBangs,omitempty"`
	}

	stage1.Assists = m.Assists
	stage1.BonusXp = m.BonusXp
	stage1.ChallengeXp = m.ChallengeXp
	stage1.DamageDone = m.DamageDone
	stage1.DamageTaken = m.DamageTaken
	stage1.Deaths = m.Deaths
	stage1.DistanceTraveled = m.DistanceTraveled
	stage1.Executions = m.Executions
	stage1.GulagDeaths = m.GulagDeaths
	stage1.GulagKills = m.GulagKills
	stage1.Headshots = m.Headshots
	stage1.KdRatio = m.KdRatio
	stage1.Kills = m.Kills
	stage1.LongestStreak = m.LongestStreak
	stage1.MatchXp = m.MatchXp
	stage1.MedalXp = m.MedalXp
	stage1.MiscXp = m.MiscXp
	stage1.Nearmisses = m.Nearmisses
	stage1.ObjectiveBrCacheOpen = m.ObjectiveBrCacheOpen
	stage1.ObjectiveBrDownEnemyCircle1 = m.ObjectiveBrDownEnemyCircle1
	stage1.ObjectiveBrKioskBuy = m.ObjectiveBrKioskBuy
	stage1.ObjectiveBrMissionPickupTablet = m.ObjectiveBrMissionPickupTablet
	stage1.ObjectiveLastStandKill = m.ObjectiveLastStandKill
	stage1.PercentTimeMoving = m.PercentTimeMoving
	stage1.Rank = m.Rank
	stage1.Score = m.Score
	stage1.ScorePerMinute = m.ScorePerMinute
	stage1.ScoreXp = m.ScoreXp
	stage1.TeamPlacement = m.TeamPlacement
	stage1.TeamSurvivalTime = m.TeamSurvivalTime
	stage1.TimePlayed = m.TimePlayed
	stage1.TotalXp = m.TotalXp
	stage1.WallBangs = m.WallBangs

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.FullMatchInfoResponseDataAllPlayersItems0PlayerStatsAdditionalProperties) == 0 {
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.FullMatchInfoResponseDataAllPlayersItems0PlayerStatsAdditionalProperties)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 {
		return additional, nil
	}

	// concatenate the 2 objects
	props[len(props)-1] = ','
	return append(props, additional[1:]...), nil
}

// Validate validates this full match info response data all players items0 player stats
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerStats) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerStats) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FullMatchInfoResponseDataAllPlayersItems0PlayerStats) UnmarshalBinary(b []byte) error {
	var res FullMatchInfoResponseDataAllPlayersItems0PlayerStats
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
